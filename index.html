<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æš—å·å¤‰æ›å™¨ï¼ˆåŒæ–¹å‘ï¼‰</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    textarea, select { width: 100%; padding: 10px; font-size: 1em; margin-top: 10px; }
    label { font-weight: bold; margin-top: 20px; display: block; }
  </style>
</head>
<body>
  <h1>æš—å·å¤‰æ›å™¨ï¼ˆæš—å·åŒ–ï¼å¾©å·ï¼‰</h1>

  <label for="mode">ãƒ¢ãƒ¼ãƒ‰é¸æŠï¼š</label>
  <select id="mode">
    <option value="encode">ğŸ” æš—å·åŒ–ï¼ˆã‹ãªâ†’æ¼¢å­—ï¼‹æ•°å­—ï¼‰</option>
    <option value="decode">ğŸ”“ å¾©å·ï¼ˆæ¼¢å­—ï¼‹æ•°å­—â†’ã‹ãªï¼‰</option>
  </select>

  <label for="inputText">å…¥åŠ›ï¼š</label>
  <textarea id="inputText" rows="3" placeholder="ä¾‹ï¼šã‹ãã«ã‚“301 ã¾ãŸã¯ æœ§éœ§å¿éš HZG"></textarea>

  <label for="outputText">å¤‰æ›çµæœï¼š</label>
  <textarea id="outputText" rows="3" readonly></textarea>

  <script>
    const kanaToKanji = {
      "ã‚":"é¾","ã„":"é¶´","ã†":"éœ","ãˆ":"é›·","ãŠ":"é·²",
      "ã‹":"æœ§","ã":"é³³","ã":"éœ§","ã‘":"ç¿¼","ã“":"æ–‘",
      "ã•":"å¤œ","ã—":"å¤©","ã™":"æ¬¡","ã›":"é›","ã":"é·¹",
      "ãŸ":"è™","ã¡":"é¬¼","ã¤":"è“®","ã¦":"èŠ","ã¨":"æ¼£",
      "ãª":"å¤","ã«":"å¿","ã¬":"ç£","ã­":"å½±","ã®":"å¤¢",
      "ã¯":"èŠ’","ã²":"ç«","ãµ":"è“¬","ã¸":"èˆŸ","ã»":"ç¯",
      "ã¾":"å³°","ã¿":"æ°´","ã‚€":"é›²","ã‚":"éœœ","ã‚‚":"æ¾",
      "ã‚„":"å¼“","ã‚†":"é›ª","ã‚ˆ":"å‡ª",
      "ã‚‰":"é›·","ã‚Š":"å·","ã‚‹":"æ¹–","ã‚Œ":"æ…§","ã‚":"éœ²",
      "ã‚":"å’Œ","ã‚’":"å®‡","ã‚“":"éš "
    };

    const digitMap = { "0":"Z","1":"G","2":"O","3":"H","4":"J","5":"F","6":"P","7":"X","8":"Y","9":"I" };
    const reverseKana = Object.fromEntries(Object.entries(kanaToKanji).map(([k,v]) => [v,k]));
    const reverseDigit = Object.fromEntries(Object.entries(digitMap).map(([k,v]) => [v,k]));

    const dakutenMap = {
      'ãŒ':'ã‹-','ã':'ã-','ã':'ã-','ã’':'ã‘-','ã”':'ã“-',
      'ã–':'ã•-','ã˜':'ã—-','ãš':'ã™-','ãœ':'ã›-','ã':'ã-',
      'ã ':'ãŸ-','ã¢':'ã¡-','ã¥':'ã¤-','ã§':'ã¦-','ã©':'ã¨-',
      'ã°':'ã¯-','ã³':'ã²-','ã¶':'ãµ-','ã¹':'ã¸-','ã¼':'ã»-',
      'ã‚”':'ã†-'
    };
    const handakuMap = {
      'ã±':'ã¯^','ã´':'ã²^','ã·':'ãµ^','ãº':'ã¸^','ã½':'ã»^'
    };
    const smallKanaMap = {
      'ã':'ã‚\'','ãƒ':'ã„\'','ã…':'ã†\'','ã‡':'ãˆ\'','ã‰':'ãŠ\'',
      'ã‚ƒ':'ã‚„\'','ã‚…':'ã‚†\'','ã‚‡':'ã‚ˆ\'','ã£':'ã¤\''
    };

    function encode(text) {
      let result = '';
      for (let char of text) {
        if (digitMap[char]) {
          result += digitMap[char];
        } else if (dakutenMap[char]) {
          result += kanaToKanji[dakutenMap[char][0]] + '-';
        } else if (handakuMap[char]) {
          result += kanaToKanji[handakuMap[char][0]] + '^';
        } else if (smallKanaMap[char]) {
          result += kanaToKanji[smallKanaMap[char][0]] + '\'';
        } else if (kanaToKanji[char]) {
          result += kanaToKanji[char];
        } else {
          result += char;
        }
      }
      return result;
    }

    function decode(text) {
      let result = '';
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        const next = text[i + 1];
        if (reverseDigit[c]) {
          result += reverseDigit[c];
        } else if (next === '-') {
          result += Object.entries(dakutenMap).find(([k,v]) => v === reverseKana[c] + '-')?.[0] || c;
          i++;
        } else if (next === '^') {
          result += Object.entries(handakuMap).find(([k,v]) => v === reverseKana[c] + '^')?.[0] || c;
          i++;
        } else if (next === "'") {
          result += Object.entries(smallKanaMap).find(([k,v]) => v === reverseKana[c] + "'")?.[0] || c;
          i++;
        } else {
          result += reverseKana[c] || c;
        }
      }
      return result;
    }

    const inputEl = document.getElementById("inputText");
    const outputEl = document.getElementById("outputText");
    const modeEl = document.getElementById("mode");

    inputEl.addEventListener("input", convert);
    modeEl.addEventListener("change", convert);

    function convert() {
      const mode = modeEl.value;
      const text = inputEl.value;
      const result = (mode === "encode") ? encode(text) : decode(text);
      outputEl.value = result;
    }
  </script>
</body>
</html>
